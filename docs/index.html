<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Adaptive Hybrid Speech Denoising – Interactive Demo</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --card-soft: #020617;
      --accent: #38bdf8;
      --accent-soft: #0ea5e9;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%);
      color: var(--text);
    }
    a { color: var(--accent-soft); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 16px 48px;
    }
    .header {
      text-align: center;
      margin-bottom: 32px;
    }
    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(56,189,248,0.12);
      border: 1px solid rgba(56,189,248,0.4);
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 28px;
      letter-spacing: .03em;
    }
    .subtitle {
      margin: 0;
      font-size: 14px;
      color: var(--text-soft);
    }

    .grid {
      display: grid;
      gap: 20px;
    }
    @media (min-width: 900px) {
      .grid-2 {
        grid-template-columns: 2fr 1.5fr;
      }
      .grid-3 {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937 0, #020617 65%);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 18px 18px 16px;
      box-shadow: 0 18px 40px rgba(0,0,0,.6);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .card-title {
      font-size: 16px;
      font-weight: 600;
    }
    .card-tag {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--text-soft);
    }
    .card-body {
      font-size: 13px;
      color: var(--text-soft);
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin: 28px 0 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .section-title span {
      font-size: 14px;
      font-weight: 400;
      color: var(--text-soft);
    }

    .audio-grid {
      display: grid;
      gap: 10px;
    }
    @media (min-width: 700px) {
      .audio-grid {
        grid-template-columns: repeat(2, minmax(0,1fr));
      }
    }
    .audio-item label {
      display: block;
      font-size: 12px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }
    audio {
      width: 100%;
    }

    .img-wrap {
      margin-top: 10px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--card-soft);
    }
    .img-wrap img {
      width: 100%;
      display: block;
    }
    .img-caption {
      font-size: 11px;
      color: var(--text-soft);
      padding: 6px 10px 8px;
      border-top: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--text-soft);
    }
    .control input[type="file"] {
      font-size: 12px;
    }
    select, input[type="range"], input[type="number"] {
      background: #020617;
      color: var(--text);
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 10px;
      font-size: 12px;
    }
    input[type="range"] {
      width: 140px;
      padding: 0;
    }
    .btn {
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      border-radius: 999px;
      border: none;
      padding: 7px 16px;
      font-size: 12px;
      font-weight: 500;
      color: #0b1120;
      cursor: pointer;
      box-shadow: 0 12px 25px rgba(56,189,248,0.4);
    }
    .btn:disabled {
      opacity: .55;
      cursor: default;
      box-shadow: none;
    }

    .pill {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text-soft);
    }
    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent-soft);
    }
    .small {
      font-size: 11px;
      color: var(--text-soft);
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <div class="badge">ELEC5305 · Adaptive Hybrid Speech Denoising</div>
      <h1>Interactive Speech Enhancement Demo</h1>
      <p class="subtitle">
        Real speech, classical denoisers, and a browser-based noise playground.
      </p>
    </header>

    <!-- ====== TOP GRID: LEFT (EXAMPLE), RIGHT (METRICS) ====== -->
    <section class="grid grid-2">
      <!-- Fixed example card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">Fixed Example · OSR_us_000_0031_8k</div>
          <div class="card-tag">Clean vs Noisy vs Denoised</div>
        </div>
        <div class="card-body">
          <p>
            A real English sentence from the Open Speech Repository is mixed
            with noise and enhanced by three classical methods implemented in MATLAB.
          </p>

          <div class="audio-grid" style="margin-top:10px;">
            <div class="audio-item">
              <label>Clean speech</label>
              <audio controls src="../examples/osr_0031/input_OSR_us_000_0031_8k.wav"></audio>
            </div>
            <div class="audio-item">
              <label>Noisy mixture</label>
              <audio controls src="../examples/osr_0031/noisy.wav"></audio>
            </div>
            <div class="audio-item">
              <label>Wiener denoised</label>
              <audio controls src="../examples/osr_0031/wiener.wav"></audio>
            </div>
            <div class="audio-item">
              <label>Spectral subtraction denoised</label>
              <audio controls src="../examples/osr_0031/spectral.wav"></audio>
            </div>
            <div class="audio-item" style="grid-column:1/-1;">
              <label>Adaptive hybrid denoised</label>
              <audio controls src="../examples/osr_0031/hybrid.wav"></audio>
            </div>
          </div>

          <div class="img-wrap" style="margin-top:12px;">
            <img src="../results/comparison_waveforms.png" alt="Waveform comparison" />
            <div class="img-caption">
              Waveform comparison for OSR_us_000_0031_8k:
              clean, noisy, Wiener, spectral subtraction and adaptive hybrid.
            </div>
          </div>
        </div>
      </div>

      <!-- Experiment metrics card -->
      <div class="card">
        <div class="card-header">
          <div class="card-title">Batch Experiments · SNR Improvement</div>
          <div class="card-tag">Whitehum · Highfreq · Babble</div>
        </div>
        <div class="card-body">
          <p>
            The denoisers are systematically evaluated across multiple speech
            files, noise types and input SNR levels (0 / 5 / 10 / 15 dB).
          </p>
          <p class="small" style="margin-top:4px;">
            Figures below are generated from <code>experiment_results.csv</code>
            using <code>plot_experiment_results.m</code>.
          </p>

          <div class="img-wrap" style="margin-top:10px;">
            <img src="../results/exp_whitehum_snr_improvement.png"
                 alt="SNR improvement - whitehum" />
            <div class="img-caption">
              Average SNR improvement vs input SNR for white + 50 Hz hum noise.
            </div>
          </div>

          <div class="img-wrap" style="margin-top:10px;">
            <img src="../results/exp_highfreq_snr_improvement.png"
                 alt="SNR improvement - highfreq" />
            <div class="img-caption">
              SNR improvement for high-frequency noise (spectral hiss).
            </div>
          </div>

          <div class="img-wrap" style="margin-top:10px;">
            <img src="../results/exp_babble_snr_improvement.png"
                 alt="SNR improvement - babble" />
            <div class="img-caption">
              SNR improvement for multi-speaker babble noise.
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ====== TRY YOUR OWN FILE ====== -->
    <h2 class="section-title" style="margin-top:32px;">
      Try Your Own File
      <span>(browser-side noise injection · original MATLAB denoising in repo)</span>
    </h2>

    <section class="card">
      <div class="card-header">
        <div class="card-title">Noise playground (Web Audio API)</div>
        <div class="pill">
          <div class="pill-dot"></div>
          client-side · no upload to server
        </div>
      </div>
      <div class="card-body">
        <p>
          Upload a short WAV file, choose a noise type and a target SNR, and
          generate a noisy version directly in your browser. This demonstrates
          the same SNR control used in the MATLAB experiments.
        </p>

        <div class="control-row" style="margin-top:12px;">
          <div class="control" style="flex:1 1 200px;">
            <label for="fileInput">1. Upload clean speech (mono WAV recommended)</label>
            <input type="file" id="fileInput" accept=".wav,audio/wav" />
          </div>

          <div class="control">
            <label for="noiseType">2. Noise type</label>
            <select id="noiseType">
              <option value="white">White + hum</option>
              <option value="highfreq">High-frequency hiss</option>
              <option value="babble">Babble-like (clustered bursts)</option>
            </select>
          </div>

          <div class="control">
            <label for="snrRange">3. Target SNR (dB)</label>
            <div style="display:flex;align-items:center;gap:6px;">
              <input type="range" id="snrRange" min="0" max="20" step="1" value="5" />
              <input type="number" id="snrValue" min="0" max="20" step="1" value="5"
                     style="width:50px;text-align:center;" />
            </div>
          </div>

          <div class="control">
            <label>&nbsp;</label>
            <button class="btn" id="processBtn" disabled>Generate noisy version</button>
          </div>
        </div>

        <div class="audio-grid" style="margin-top:12px;">
          <div class="audio-item">
            <label>Clean (uploaded)</label>
            <audio id="playerClean" controls></audio>
          </div>
          <div class="audio-item">
            <label>Noisy (browser-generated)</label>
            <audio id="playerNoisy" controls></audio>
          </div>
        </div>

        <p class="small" style="margin-top:10px;">
          Download noisy WAV:
          <a id="downloadLink" href="#" download="noisy_browser.wav" style="display:none;">
            noisy_browser.wav
          </a>
        </p>

        <p class="small" style="margin-top:6px;">
          The full Wiener, spectral subtraction and adaptive hybrid denoising
          pipelines are implemented in MATLAB in this repository
          (<code>main_hybrid_denoise.m</code>, <code>run_batch_experiments.m</code>).
        </p>
      </div>
    </section>

    <p class="small" style="margin-top:18px;text-align:center;color:#6b7280;">
      Source code: <code>elec5305-project-TengfeiWang-540542743</code> ·
      MATLAB implementation by Tengfei Wang (540542743).
    </p>
  </div>

  <script>
    // ====== SNR slider <-> number sync ======
    const snrRange = document.getElementById('snrRange');
    const snrValue = document.getElementById('snrValue');
    snrRange.addEventListener('input', () => { snrValue.value = snrRange.value; });
    snrValue.addEventListener('input', () => { snrRange.value = snrValue.value; });

    // ====== Web Audio noise playground ======
    const fileInput   = document.getElementById('fileInput');
    const noiseType   = document.getElementById('noiseType');
    const processBtn  = document.getElementById('processBtn');
    const playerClean = document.getElementById('playerClean');
    const playerNoisy = document.getElementById('playerNoisy');
    const downloadLink= document.getElementById('downloadLink');

    let cleanArrayBuffer = null;

    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        cleanArrayBuffer = e.target.result;
        playerClean.src = URL.createObjectURL(file);
        processBtn.disabled = false;
      };
      reader.readAsArrayBuffer(file);
    });

    processBtn.addEventListener('click', async () => {
      if (!cleanArrayBuffer) return;

      processBtn.disabled = true;
      processBtn.textContent = 'Processing...';

      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioContext();
      const buffer = await audioCtx.decodeAudioData(cleanArrayBuffer.slice(0));

      const noisyBuffer = audioCtx.createBuffer(
        buffer.numberOfChannels,
        buffer.length,
        buffer.sampleRate
      );

      const snrTargetDb = parseFloat(snrRange.value);
      const snrTargetLin = Math.pow(10, snrTargetDb / 10);

      for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
        const clean = buffer.getChannelData(ch);
        const noisy = noisyBuffer.getChannelData(ch);

        // clean power estimate
        let pClean = 0;
        for (let i = 0; i < clean.length; i++) pClean += clean[i] * clean[i];
        pClean /= clean.length;

        // generate different noise types
        const noiseTemp = new Float32Array(clean.length);
        let pNoise = 0;

        const type = noiseType.value;
        if (type === 'white') {
          // white + low-frequency hum
          for (let i = 0; i < clean.length; i++) {
            const white = Math.random() * 2 - 1;
            const t = i / buffer.sampleRate;
            const hum = 0.3 * Math.sin(2 * Math.PI * 50 * t);
            const n = white + hum;
            noiseTemp[i] = n;
            pNoise += n * n;
          }
        } else if (type === 'highfreq') {
          // high-frequency hiss: white noise filtered by simple high-pass shape
          for (let i = 0; i < clean.length; i++) {
            const white = Math.random() * 2 - 1;
            const t = i / buffer.sampleRate;
            const env = 0.2 + 0.8 * (i / clean.length); // more highfreq later
            const n = white * env;
            noiseTemp[i] = n;
            pNoise += n * n;
          }
        } else {
          // "babble-like": bursts of noise in random segments
          const burstProb = 0.02;
          let active = false;
          let remaining = 0;
          for (let i = 0; i < clean.length; i++) {
            if (!active && Math.random() < burstProb) {
              active = true;
              remaining = Math.floor(buffer.sampleRate * (0.1 + Math.random() * 0.3));
            }
            let n = 0;
            if (active) {
              n = (Math.random() * 2 - 1) * 1.2;
              remaining--;
              if (remaining <= 0) active = false;
            }
            noiseTemp[i] = n;
            pNoise += n * n;
          }
        }
        pNoise /= clean.length;

        // scale noise to target SNR
        const scale = Math.sqrt(pClean / (pNoise * snrTargetLin));
        for (let i = 0; i < clean.length; i++) {
          noisy[i] = clean[i] + scale * noiseTemp[i];
        }
      }

      const noisyBlob = await audioBufferToWavBlob(noisyBuffer);
      const noisyUrl = URL.createObjectURL(noisyBlob);
      playerNoisy.src = noisyUrl;
      downloadLink.style.display = 'inline';
      downloadLink.href = noisyUrl;

      processBtn.textContent = 'Generate noisy version';
      processBtn.disabled = false;
    });

    async function audioBufferToWavBlob(buffer) {
      const numCh = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const numFrames = buffer.length;

      const bytesPerSample = 2;
      const blockAlign = numCh * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = numFrames * blockAlign;
      const headerSize = 44;
      const totalSize = headerSize + dataSize;

      const arrayBuffer = new ArrayBuffer(totalSize);
      const view = new DataView(arrayBuffer);
      let offset = 0;

      function writeString(s) {
        for (let i = 0; i < s.length; i++) {
          view.setUint8(offset++, s.charCodeAt(i));
        }
      }

      // RIFF header
      writeString('RIFF');
      view.setUint32(offset, totalSize - 8, true); offset += 4;
      writeString('WAVE');

      // fmt chunk
      writeString('fmt ');
      view.setUint32(offset, 16, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2;
      view.setUint16(offset, numCh, true); offset += 2;
      view.setUint32(offset, sampleRate, true); offset += 4;
      view.setUint32(offset, byteRate, true); offset += 4;
      view.setUint16(offset, blockAlign, true); offset += 2;
      view.setUint16(offset, 16, true); offset += 2;

      // data chunk
      writeString('data');
      view.setUint32(offset, dataSize, true); offset += 4;

      const channels = [];
      for (let ch = 0; ch < numCh; ch++) {
        channels.push(buffer.getChannelData(ch));
      }
      for (let i = 0; i < numFrames; i++) {
        for (let ch = 0; ch < numCh; ch++) {
          let sample = channels[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample * 0x7fff, true);
          offset += 2;
        }
      }
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }
  </script>
</body>
</html>
