<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ELEC5305 – Adaptive Hybrid Speech Denoising Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-card: #111827;
      --bg-card-soft: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.2);
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --border-subtle: rgba(148, 163, 184, 0.3);
      --radius-xl: 18px;
      --radius-lg: 14px;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.65);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0f172a 0, #020617 48%, #000 100%);
      color: var(--text-main);
      line-height: 1.5;
      min-height: 100vh;
      padding: 40px 16px 80px;
    }

    .page {
      max-width: 1180px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 32px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 12px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid var(--accent-soft);
      font-size: 12px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 12px;
    }

    h1 {
      font-size: clamp(28px, 3vw, 34px);
      letter-spacing: 0.02em;
      margin-bottom: 6px;
    }

    header p {
      font-size: 14px;
      color: var(--text-soft);
      max-width: 540px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(0, 1.1fr);
      gap: 22px;
      margin-bottom: 32px;
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937 0, #020617 60%);
      border-radius: var(--radius-xl);
      padding: 18px 18px 20px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(31, 41, 55, 0.95);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -1px;
      border-radius: inherit;
      padding: 1px;
      background: radial-gradient(circle at top left,
        rgba(56, 189, 248, 0.25),
        transparent 55%);
      -webkit-mask: linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      opacity: 0.55;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 10px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .chip {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border-subtle);
      color: var(--text-soft);
      white-space: nowrap;
    }

    .card-subtitle {
      font-size: 13px;
      color: var(--text-soft);
      margin-bottom: 14px;
    }

    .row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 10px;
      margin-bottom: 8px;
    }

    .row-label {
      font-size: 13px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    audio {
      width: 100%;
      height: 32px;
    }

    .section-label {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
      margin-bottom: 8px;
    }

    .figure-thumb {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 10px;
      border-radius: var(--radius-lg);
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(31, 41, 55, 0.95);
      margin-bottom: 8px;
    }

    .figure-thumb img {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #020617;
      object-fit: contain;
    }

    .figure-caption {
      font-size: 12px;
      color: var(--text-soft);
    }

    .pill-group {
      display: inline-flex;
      background: rgba(15, 23, 42, 0.9);
      border-radius: 999px;
      padding: 4px;
      border: 1px solid var(--border-subtle);
      gap: 4px;
      margin-bottom: 8px;
      font-size: 11px;
    }

    .pill {
      padding: 3px 9px;
      border-radius: 999px;
      color: var(--text-soft);
      background: transparent;
    }

    .pill.active {
      background: var(--accent-soft);
      color: var(--accent);
    }

    /* === Try-your-own section === */
    .section {
      margin-top: 30px;
    }

    .section h2 {
      font-size: 18px;
      margin-bottom: 10px;
    }

    .section p {
      font-size: 13px;
      color: var(--text-soft);
      margin-bottom: 14px;
    }

    .try-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.6fr);
      gap: 16px;
    }

    .field-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--text-soft);
    }

    input[type="file"] {
      font-size: 13px;
    }

    select,
    input[type="range"] {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border-subtle);
      color: var(--text-main);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 13px;
    }

    input[type="range"] {
      width: 150px;
      padding: 0;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 13px;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #4ade80);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 8px 20px rgba(22, 163, 74, 0.45);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }

    .chip-small {
      font-size: 11px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .download-link {
      font-size: 12px;
      color: var(--accent);
      text-decoration: none;
    }

    .download-link:hover {
      text-decoration: underline;
    }

    .hint {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
    }

    @media (max-width: 960px) {
      body {
        padding: 24px 12px 60px;
      }
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
      .card {
        padding: 16px 14px 18px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="badge">ELEC5305 · Adaptive Hybrid Speech Denoising</div>
      <h1>Interactive Speech Enhancement Demo</h1>
      <p>
        Real English speech from the Open Speech Repository, classical denoisers
        implemented in MATLAB, and a browser-side noise playground that mimics
        the experimental setup used in the report.
      </p>
    </header>

    <!-- TOP GRID: fixed example + batch SNR results -->
    <div class="grid">
      <!-- Fixed example -->
      <section class="card">
        <div class="card-header">
          <div class="card-title">Fixed Example · OSR_us_000_0031_8k</div>
          <div class="chip">Clean vs Noisy vs Denoised</div>
        </div>
        <p class="card-subtitle">
          A real English utterance from the Open Speech Repository mixed with
          synthetic noise and enhanced by three classical methods implemented in MATLAB.
        </p>

        <div class="row">
          <div>
            <div class="row-label">Clean speech (truncated)</div>
            <audio controls preload="metadata">
              <source src="../examples/osr_0031/input_truncated.wav" type="audio/wav" />
            </audio>
          </div>
          <div>
            <div class="row-label">Noisy mixture</div>
            <audio controls preload="metadata">
              <source src="../examples/osr_0031/noisy.wav" type="audio/wav" />
            </audio>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="row-label">Wiener denoised</div>
            <audio controls preload="metadata">
              <source src="../examples/osr_0031/wiener.wav" type="audio/wav" />
            </audio>
          </div>
          <div>
            <div class="row-label">Spectral subtraction denoised</div>
            <audio controls preload="metadata">
              <source src="../examples/osr_0031/spectral.wav" type="audio/wav" />
            </audio>
          </div>
        </div>

        <div class="row">
          <div style="grid-column: 1 / -1;">
            <div class="row-label">Adaptive hybrid denoised</div>
            <audio controls preload="metadata">
              <source src="../examples/osr_0031/hybrid.wav" type="audio/wav" />
            </audio>
          </div>
        </div>

        <div style="margin-top: 10px;">
          <div class="section-label">Waveform comparison</div>
          <div class="figure-thumb">
            <img
              src="../examples/osr_0031/comparison_waveforms.png"
              alt="Waveform comparison for clean, noisy, Wiener, spectral subtraction and adaptive hybrid speech."
            />
            <div class="figure-caption">
              Waveform comparison for OSR_us_000_0031_8k:
              clean, noisy, Wiener, spectral subtraction and adaptive hybrid.
            </div>
          </div>
        </div>
      </section>

      <!-- Batch SNR experiments -->
      <section class="card">
        <div class="card-header">
          <div class="card-title">Batch Experiments · SNR Improvement</div>
          <div class="pill-group">
            <span class="pill active">Whitehum</span>
            <span class="pill">Highfreq</span>
            <span class="pill">Babble</span>
          </div>
        </div>
        <p class="card-subtitle">
          Denoisers are evaluated across multiple speech files, noise types and input
          SNR levels (0 / 5 / 10 / 15 dB). Figures below are generated from
          <code>experiment_results.csv</code> by <code>plot_experiment_results.m</code>.
        </p>

        <div class="section-label">Average SNR improvement (dB)</div>

        <div class="figure-thumb">
          <img
            src="../results/exp_whitehum_snr_improvement.png"
            alt="Average SNR improvement for white + 50 Hz hum noise."
          />
          <div class="figure-caption">
            White + 50 Hz hum noise. Spectral subtraction is slightly stronger than
            Wiener at low input SNR, while the hybrid method trades a small amount
            of SNR for reduced musical noise.
          </div>
        </div>

        <div class="figure-thumb">
          <img
            src="../results/exp_highfreq_snr_improvement.png"
            alt="Average SNR improvement for high-frequency hiss."
          />
          <div class="figure-caption">
            High-frequency hiss. Both classical methods achieve substantial SNR
            gains; the hybrid method becomes more conservative at higher input SNR
            to avoid over-suppressing fricatives.
          </div>
        </div>

        <div class="figure-thumb">
          <img
            src="../results/exp_babble_snr_improvement.png"
            alt="Average SNR improvement for multi-speaker babble."
          />
          <div class="figure-caption">
            Multi-speaker babble noise. Improvements are smaller because speech and
            interference share similar spectra, but all denoisers still provide
            consistent positive SNR gains across operating points.
          </div>
        </div>
      </section>
    </div>

    <!-- TRY YOUR OWN -->
    <section class="section">
      <div class="card">
        <div class="card-header">
          <h2>Try Your Own File · Browser-Side Noise Playground</h2>
          <div class="chip-small">
            Client-side only · original MATLAB denoising remains in the GitHub repo
          </div>
        </div>
        <p>
          Upload a short WAV file (mono recommended), select a noise type and a target
          SNR, and generate a noisy version directly in the browser using the Web
          Audio API. This mimics the SNR control used in the MATLAB experiments, but
          all processing happens locally in your browser.
        </p>

        <div class="try-grid">
          <div>
            <div class="section-label">1. Upload clean speech</div>
            <div class="field-row">
              <input id="fileInput" type="file" accept="audio/wav,audio/x-wav" />
              <span class="hint">
                For best results, use a 5–20 s mono WAV file.
              </span>
            </div>

            <div class="row" style="margin-top: 8px;">
              <div>
                <div class="row-label">Clean (uploaded)</div>
                <audio id="cleanPlayer" controls preload="metadata"></audio>
              </div>
              <div>
                <div class="row-label">
                  Noisy (browser-generated)
                </div>
                <audio id="noisyPlayer" controls preload="metadata"></audio>
              </div>
            </div>

            <hr style="border:none;border-top:1px solid rgba(31,41,55,0.8);margin:16px 0 10px;" />

            <div class="section-label">2. Noise configuration</div>
            <div class="field-row">
              <span>Noise type</span>
              <select id="noiseType">
                <option value="whitehum">White + 50 Hz hum</option>
                <option value="highfreq">High-frequency hiss</option>
                <option value="babble">Babble-like noise</option>
              </select>

              <span>Target SNR (dB)</span>
              <input id="snrSlider" type="range" min="0" max="20" step="1" value="5" />
              <span id="snrValue">5 dB</span>

              <button id="generateBtn" class="btn" disabled>
                Generate noisy version
              </button>
            </div>

            <div class="field-row" style="margin-top:6px;">
              <a id="downloadLink" class="download-link" href="#" style="display:none;">
                Download generated noisy WAV
              </a>
            </div>

            <p class="hint">
              This demo only adds noise in the browser. To reproduce the full
              MATLAB denoising pipeline, please run
              <code>main_hybrid_denoise.m</code> and
              <code>run_batch_experiments.m</code> in the repository.
            </p>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- Simple browser-side SNR-controlled noise injection ---
    const fileInput = document.getElementById("fileInput");
    const cleanPlayer = document.getElementById("cleanPlayer");
    const noisyPlayer = document.getElementById("noisyPlayer");
    const generateBtn = document.getElementById("generateBtn");
    const noiseTypeSelect = document.getElementById("noiseType");
    const snrSlider = document.getElementById("snrSlider");
    const snrValue = document.getElementById("snrValue");
    const downloadLink = document.getElementById("downloadLink");

    let audioContext;
    let cleanBuffer = null;

    snrSlider.addEventListener("input", () => {
      snrValue.textContent = snrSlider.value + " dB";
    });

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      const arrayBuffer = await file.arrayBuffer();
      cleanBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // Create object URL for the original file so the audio element can play it.
      const cleanUrl = URL.createObjectURL(file);
      cleanPlayer.src = cleanUrl;
      cleanPlayer.load();

      generateBtn.disabled = false;
      downloadLink.style.display = "none";
    });

    generateBtn.addEventListener("click", async () => {
      if (!cleanBuffer || !audioContext) return;

      const snrDb = parseFloat(snrSlider.value || "5");
      const noiseType = noiseTypeSelect.value;

      const numChannels = cleanBuffer.numberOfChannels;
      const length = cleanBuffer.length;
      const sampleRate = cleanBuffer.sampleRate;

      const offline = new OfflineAudioContext(numChannels, length, sampleRate);
      const cleanSource = offline.createBufferSource();
      cleanSource.buffer = cleanBuffer;

      const cleanGain = offline.createGain();
      cleanSource.connect(cleanGain);
      cleanGain.connect(offline.destination);

      // Compute clean power
      let cleanPower = 0;
      const tmp = cleanBuffer.getChannelData(0);
      for (let i = 0; i < tmp.length; i++) {
        cleanPower += tmp[i] * tmp[i];
      }
      cleanPower /= tmp.length;

      const snrLinear = Math.pow(10, snrDb / 10);
      const noisePowerTarget = cleanPower / snrLinear;
      const noiseStd = Math.sqrt(noisePowerTarget);

      // Create noise buffer
      const noiseBuffer = offline.createBuffer(numChannels, length, sampleRate);
      for (let ch = 0; ch < numChannels; ch++) {
        const channelData = noiseBuffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          let n = (Math.random() * 2 - 1); // white
          const t = i / sampleRate;

          if (noiseType === "whitehum") {
            // Add a low-frequency hum at 50 Hz
            n += 0.4 * Math.sin(2 * Math.PI * 50 * t);
          } else if (noiseType === "highfreq") {
            // Emphasise high frequencies using a simple differentiator
            const w = (Math.random() * 2 - 1);
            const v = (Math.random() * 2 - 1);
            n = (w - v) * 1.4;
          } else if (noiseType === "babble") {
            // Babble-like: sum of several independent "speaker" envelopes
            const s1 = Math.random() * Math.sin(2 * Math.PI * 2.1 * t);
            const s2 = Math.random() * Math.sin(2 * Math.PI * 2.7 * t + 1.1);
            const s3 = Math.random() * Math.sin(2 * Math.PI * 3.3 * t + 2.4);
            n = 0.6 * (s1 + s2 + s3) + 0.4 * n;
          }

          channelData[i] = noiseStd * n;
        }
      }

      const noiseSource = offline.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.connect(offline.destination);

      cleanSource.start();
      noiseSource.start();

      const mixed = await offline.startRendering();

      // Export to WAV
      const wavBlob = bufferToWavBlob(mixed);
      const url = URL.createObjectURL(wavBlob);
      noisyPlayer.src = url;
      noisyPlayer.load();

      downloadLink.href = url;
      downloadLink.download = "noisy_generated.wav";
      downloadLink.style.display = "inline";
    });

    function bufferToWavBlob(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;

      let result;
      if (numChannels === 2) {
        const channelData0 = buffer.getChannelData(0);
        const channelData1 = buffer.getChannelData(1);
        result = interleave(channelData0, channelData1);
      } else {
        result = buffer.getChannelData(0);
      }

      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      const bufferLength = 44 + result.length * bytesPerSample;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);

      /* RIFF identifier */
      writeString(view, 0, "RIFF");
      /* file length */
      view.setUint32(4, 36 + result.length * bytesPerSample, true);
      /* RIFF type */
      writeString(view, 8, "WAVE");
      /* format chunk identifier */
      writeString(view, 12, "fmt ");
      /* format chunk length */
      view.setUint32(16, 16, true);
      /* sample format (raw) */
      view.setUint16(20, format, true);
      /* channel count */
      view.setUint16(22, numChannels, true);
      /* sample rate */
      view.setUint32(24, sampleRate, true);
      /* byte rate (sample rate * block align) */
      view.setUint32(28, sampleRate * blockAlign, true);
      /* block align (channel count * bytes per sample) */
      view.setUint16(32, blockAlign, true);
      /* bits per sample */
      view.setUint16(34, bitDepth, true);
      /* data chunk identifier */
      writeString(view, 36, "data");
      /* data chunk length */
      view.setUint32(40, result.length * bytesPerSample, true);

      // write PCM samples
      floatTo16BitPCM(view, 44, result);

      return new Blob([arrayBuffer], { type: "audio/wav" });
    }

    function interleave(inputL, inputR) {
      const length = inputL.length + inputR.length;
      const result = new Float32Array(length);

      let index = 0;
      let inputIndex = 0;

      while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
      }
      return result;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function floatTo16BitPCM(output, offset, input) {
      for (let i = 0; i < input.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, input[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7fff;
        output.setInt16(offset, s, true);
      }
    }
  </script>
</body>
</html>
